# -*- coding: utf-8 -*-
"""Bayesian Forecaster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tS3MxFYKsqH7jUukdnoTKAaM5pQ9pHxu

# **Bayesian Forecaster with No Regime Switching**
"""

import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Define the prior parameters
alpha_0 = 3
beta_0 = 0.01

# Signal about prior variance
tilde_sigma2 = 0.022
tau2 = 0.005

# Update the posterior parameters
alpha_1 = alpha_0 + 0.5
beta_1 = beta_0 + ((tilde_sigma2 - beta_0)**2) / (2 * tau2)

# Predictive distribution
mu = 0.01  # mean return

# Generate samples from the predictive distribution
def predictive_samples(alpha, beta, mu, num_samples=1000):
    sigma2_samples = stats.invgamma.rvs(a=alpha, scale=beta, size=num_samples)
    return np.random.normal(loc=mu, scale=np.sqrt(sigma2_samples))

num_samples = 1000
predicted_returns = predictive_samples(alpha_1, beta_1, mu, num_samples)

# Asset price prediction
P_t = 100  # current price

# Predict future prices
P_t1_samples = P_t * np.exp(predicted_returns)

# Plot the predictive distribution of future prices
fig = plt.figure(figsize=(12, 8))

sns.histplot(P_t1_samples, bins=50, kde=False, stat="density", color='g', alpha=0.6, label='Histogram')

# Kernel density estimate (KDE) for the PDF
sns.kdeplot(P_t1_samples, color='b', linewidth=2, label='PDF')
plt.title('Predictive Distribution of Future Asset Prices')
plt.xlabel('Future Asset Price')
plt.ylabel('Density')
plt.legend(['PDF of Asset Payoffs', 'Asset Payoffs Post Signals'])
plt.show()

# Expected future price
expected_P_t1 = np.mean(P_t1_samples)
print(f"Expected future asset price: {expected_P_t1:.2f}")

# Predict future prices at a specific confidence level (e.g., 95%)
confidence_level = 0.95
lower_bound = np.percentile(P_t1_samples, (1 - confidence_level) / 2 * 100)
upper_bound = np.percentile(P_t1_samples, (1 + confidence_level) / 2 * 100)
print(f"{confidence_level * 100:.0f}% confidence interval for future asset price: [{lower_bound:.2f}, {upper_bound:.2f}]")

"""# **Bayesian Forecaster with Regime Switching between Expansions and Recessions**"""

class BayesianForecaster:
    def __init__(self, alpha_E0, beta_E0, alpha_R0, beta_R0, sigma_n, sigma_n_matrix, transition_probs, mu_E, mu_R):
        # Prior parameters
        self.alpha_E0 = alpha_E0
        self.beta_E0 = beta_E0
        self.alpha_R0 = alpha_R0
        self.beta_R0 = beta_R0
        self.sigma_n = sigma_n

        # Signal Variance (Diagonal of Precision Matrix)
        self.sigma_n_matrix = sigma_n_matrix

        # Transition probabilities
        self.p_EE, self.p_ER, self.p_RE, self.p_RR = transition_probs

        # Mean returns for each regime
        self.mu_E = mu_E
        self.mu_R = mu_R

        # Initialize current regime
        self.current_regime = 'R'  # Start with recessions

        self.time_series_data = None

    def load_time_series_data(self, file_path):
       # Load the dataset
        self.time_series_data = pd.read_csv(file_path, index_col=0, parse_dates=True)
        self.time_series_data = pd.read_excel(file_path, index_col=0, parse_dates=True)

        # Log-transform the prices for stability
        self.time_series_data['LogPrice'] = np.log(self.time_series_data['Price'])

        # Compute daily returns
        self.time_series_data['Return'] = self.time_series_data['LogPrice'].diff().dropna()

    def update_posterior_params(self, signal, risk_index):
      sigma_n = self.sigma_n_matrix[risk_index, risk_index]
      if self.current_regime == 'E':
            alpha_post = self.alpha_E0 + 0.5
            beta_post = self.beta_E0 + (signal - self.beta_E0)**2 / (2 * self.sigma_n)
      else:
            alpha_post = self.alpha_R0 + 0.5
            beta_post = self.beta_R0 + (signal - self.beta_R0)**2 / (2 * self.sigma_n)
      return alpha_post, beta_post

    def predictive_samples(self, alpha_post, beta_post, num_samples=100000):
        sigma2_samples = stats.invgamma.rvs(a=alpha_post, scale=beta_post, size=num_samples)
        if self.current_regime == 'E':
            return np.random.normal(loc=self.mu_E, scale=np.sqrt(sigma2_samples))
        else:
            return np.random.normal(loc=self.mu_R, scale=np.sqrt(sigma2_samples))

    def predict_future_price(self, current_price, signal, risk_index, num_samples=100000):
        alpha_post, beta_post = self.update_posterior_params(signal, risk_index)
        predicted_returns = self.predictive_samples(alpha_post, beta_post, num_samples)
        future_prices = current_price * np.exp(predicted_returns)
        return future_prices

    def switch_regime(self):
        if self.current_regime == 'R':
            self.current_regime = 'R' if np.random.rand() < self.p_EE else 'E'
        else:
            self.current_regime = 'E' if np.random.rand() < self.p_RR else 'R'

    def plot_predictive_distribution(self, future_prices):
        plt.figure(figsize=(12, 8))
        sns.histplot(future_prices, bins=50, kde=False, stat="density", color='maroon', alpha=1, label='Asset Payoffs Post Signals')
        sns.kdeplot(future_prices, color='green', linewidth=2, label='PDF')
        plt.title('Predictive Distribution of Future Asset Prices')
        plt.xlabel('Future Asset Price')
        plt.ylabel('Density')
        plt.legend()
        plt.show()

    def expected_future_price(self, future_prices):
        return np.mean(future_prices)

    def confidence_interval(self, future_prices, confidence_level=0.95):
        lower_bound = np.percentile(future_prices, (1 - confidence_level) / 2 * 100)
        upper_bound = np.percentile(future_prices, (1 + confidence_level) / 2 * 100)
        return lower_bound, upper_bound

    def mse(self, future_prices, actual_prices):
      return np.mean(((future_prices-actual_prices)**2)/len(actual_prices))

# Precision Matrix (with Diagonal Elements)

precision_matrix = np.array([
    [1/0.005, 0],    # Signal Precision for Asset 1
    [0, 1/0.075]     # Signal Precision for Asset 2
])

sigma_n_matrix = np.linalg.inv(precision_matrix)

# Initialize the Bayesian forecaster
forecaster = BayesianForecaster(
    alpha_E0=3, beta_E0=0.01,
    alpha_R0=3, beta_R0=0.02,
    sigma_n_matrix=sigma_n_matrix,
    sigma_n=0.2,
    transition_probs=(0.9, 0.1, 0.2, 0.8),
    mu_E=0.02, mu_R=-0.01
)

# Simulate a signal about prior variance for asset 1
signal = 0.022
risk_index = 0
current_price = 110
num_samples = 100000

# Predict future prices
future_prices = forecaster.predict_future_price(current_price, signal, risk_index, num_samples)

# Plot the predictive distribution
forecaster.plot_predictive_distribution(future_prices)


# Actual Prices
actual_prices = current_price * np.exp(np.random.normal(0, 0.02, num_samples))  # Using some assumed actual returns

# Mean Squared Error
mse = forecaster.mse(future_prices, actual_prices)
print(f"Mean Squared Error: {mse:.2f}")

# Print the expected future price
expected_price = forecaster.expected_future_price(future_prices)
print(f"Expected future asset price: {expected_price:.2f}")

# Print the confidence interval for future prices
confidence_level = 0.95
lower_bound, upper_bound = forecaster.confidence_interval(future_prices, confidence_level)
print(f"{confidence_level * 100:.0f}% confidence interval for future asset price: [{lower_bound:.2f}, {upper_bound:.2f}]")

# Switch regime for the next period
forecaster.switch_regime()
print(f"Next regime: {forecaster.current_regime}")

# Precision Matrix (with Diagonal Elements)
precision_matrix = np.array([
    [1/0.01, 0],    # Signal Precision for Asset 1
    [0, 1/0.005]     # Signal Precision for Asset 2
])

sigma_n_matrix = np.linalg.inv(precision_matrix)

# Initialize the Bayesian forecaster
forecaster = BayesianForecaster(
    alpha_E0=3, beta_E0=0.01,
    alpha_R0=3, beta_R0=0.02,
    sigma_n_matrix=sigma_n_matrix,
    sigma_n=0.6,
    transition_probs=(0.8, 0.2, 0.1, 0.9),
    mu_E=0.02, mu_R=-0.01
)

# Simulate a signal about prior variance for asset 1
signal = 0.095
risk_index = 0
current_price = 110
num_samples = 100000

# Predict future prices
future_prices = forecaster.predict_future_price(current_price, signal, risk_index, num_samples)

# Actual Prices
actual_prices = current_price * np.exp(np.random.normal(0, 0.02, num_samples))  # Using some assumed actual returns

# Mean Squared Error
mse = forecaster.mse(future_prices, actual_prices)
print(f"Mean Squared Error: {mse:.2f}")

# Plot the predictive distribution
forecaster.plot_predictive_distribution(future_prices)

# Print the expected future price
expected_price = forecaster.expected_future_price(future_prices)
print(f"Expected future asset price: {expected_price:.2f}")

# Print the confidence interval for future prices
confidence_level = 0.95
lower_bound, upper_bound = forecaster.confidence_interval(future_prices, confidence_level)
print(f"{confidence_level * 100:.0f}% confidence interval for future asset price: [{lower_bound:.2f}, {upper_bound:.2f}]")

# Switch regime for the next period
forecaster.switch_regime()
print(f"Next regime: {forecaster.current_regime}")